{"meta":{"title":"wonderful的自由空间","subtitle":"机遇总是留给有准备之人","description":"好的机遇总是留给有准备之人","author":"xiexin","url":"https://wonderfulxin.github.io"},"pages":[],"posts":[{"title":"面试经验","slug":"face-experience","date":"2016-12-23T14:37:23.000Z","updated":"2016-12-23T07:54:06.975Z","comments":true,"path":"2016/12/23/face-experience/","link":"","permalink":"https://wonderfulxin.github.io/2016/12/23/face-experience/","excerpt":"摘要:安卓面试经验","text":"摘要:安卓面试经验正文:我的第一篇","categories":[{"name":"日志","slug":"日志","permalink":"https://wonderfulxin.github.io/categories/日志/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://wonderfulxin.github.io/tags/其他/"}]},{"title":"压缩图片单例Util","slug":"ZipUtil","date":"2016-12-23T03:35:00.000Z","updated":"2016-12-23T07:54:13.873Z","comments":true,"path":"2016/12/23/ZipUtil/","link":"","permalink":"https://wonderfulxin.github.io/2016/12/23/ZipUtil/","excerpt":"摘要:压缩图片的工具类，内存经常由于图片占用空间大而内存溢出，有了这个压缩最起码会好好多。","text":"摘要:压缩图片的工具类，内存经常由于图片占用空间大而内存溢出，有了这个压缩最起码会好好多。public class ZipUtil {private static ZipUtil instance;private ZipUtil() {}public static synchronized ZipUtil getInstance() {if (instance == null) { instance = new ZipUtil();} return instance;}private File compressImage(Bitmap image) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); image.compress(Bitmap.CompressFormat.JPEG, 100, baos);//质量压缩方法，这里100表示 不压缩，把压缩后的数据存放到baos中 int options = 100; while ( baos.toByteArray().length / 1024&gt;200) { //循环判断如果压缩后图片是否大于200kb,大于继续压缩 baos.reset();//重置baos即清空baos image.compress(Bitmap.CompressFormat.JPEG, options, baos);//这里压缩options%，把压缩后的数据存放到baos中 options -= 10;//每次都减少10 }// ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());//把压缩后的数据baos存放到ByteArrayInputStream中// Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null);//把ByteArrayInputStream数据生成图片 new DateFormat(); String name = DateFormat.format(“yyyyMMdd_hhmmss”,Calendar.getInstance(Locale.CHINA)) + “.JPEG”; File f = new File( “/sdcard/Image/“+name); try { FileOutputStream fos = new FileOutputStream(f); fos.write(baos.toByteArray()); fos.flush(); fos.close(); } catch (Exception e) { e.printStackTrace(); } return f; }public File getimage(String srcPath) { BitmapFactory.Options newOpts = new BitmapFactory.Options(); //开始读入图片，此时把options.inJustDecodeBounds 设回true了 newOpts.inJustDecodeBounds = true; Bitmap bitmap = BitmapFactory.decodeFile(srcPath,newOpts);//此时返回bm为空 newOpts.inJustDecodeBounds = false; int w = newOpts.outWidth; int h = newOpts.outHeight; //现在主流手机比较多是800*480分辨率，所以高和宽我们设置为 float hh = 800f;//这里设置高度为800f float ww = 480f;//这里设置宽度为480f //缩放比。由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可 int be = 1;//be=1表示不缩放 if (w &gt; h &amp;&amp; w &gt; ww) {//如果宽度大的话根据宽度固定大小缩放 be = (int) (newOpts.outWidth / ww); } else if (w &lt; h &amp;&amp; h &gt; hh) {//如果高度高的话根据宽度固定大小缩放 be = (int) (newOpts.outHeight / hh); } if (be &lt;= 0) be = 1; newOpts.inSampleSize = be;//设置缩放比例 //重新读入图片，注意此时已经把options.inJustDecodeBounds 设回false了 bitmap = BitmapFactory.decodeFile(srcPath, newOpts); return compressImage(bitmap);//压缩好比例大小后再进行质量压缩 }}","categories":[],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://wonderfulxin.github.io/tags/安卓/"}]},{"title":"html传参数乱码","slug":"传参数乱码","date":"2016-12-23T03:35:00.000Z","updated":"2017-01-09T03:41:53.653Z","comments":true,"path":"2016/12/23/传参数乱码/","link":"","permalink":"https://wonderfulxin.github.io/2016/12/23/传参数乱码/","excerpt":"摘要:有时候会遇到传H5参数会乱码，就是一个页面用get方法带去参数，之后在另外一个页面获取参数会乱码，顺便写出获取参数的方法","text":"摘要:有时候会遇到传H5参数会乱码，就是一个页面用get方法带去参数，之后在另外一个页面获取参数会乱码，顺便写出获取参数的方法//获取参数的方法function getQueryString(name) { var reg = new RegExp(“(^|&amp;)” + name + “=([^&amp;]*)(&amp;|$)”, “i”); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;}在一个URL带上参数例如：http://127.0.0.1:8020/index.html?id=205&amp;department=部门但是这个中文会乱码，在获取的时候，这个时候我们要先给部门两个中文字先encode 之后再获取的时候再解码：index.html?id=’+id+’&amp;department=’+escape(department)+’然后获取的时候就直接unescape(getQueryString(‘department’)) 获取出来的就不是乱码了。","categories":[],"tags":[{"name":"H5","slug":"H5","permalink":"https://wonderfulxin.github.io/tags/H5/"}]},{"title":"安卓activity四种启动模式","slug":"安卓四种启动模式","date":"2016-12-23T03:35:00.000Z","updated":"2017-01-16T03:19:38.766Z","comments":true,"path":"2016/12/23/安卓四种启动模式/","link":"","permalink":"https://wonderfulxin.github.io/2016/12/23/安卓四种启动模式/","excerpt":"摘要:安卓activity的四种启动模式在面试中也是经常会用到的","text":"摘要:安卓activity的四种启动模式在面试中也是经常会用到的1.standard 模式 标准模式，默认模式，每次激活都会重新创建activity，并且放到任务栈中2.singletop模式 要是在栈顶是你要启用的activity 那就会重用这个activity 要是不是这个就重新启动activity3.singletask模式 在栈里面查找要是有的话就复用 没有的话就重建4.signleInstance模式 外部应用也可以启动你这个activity 设置启动模式的位置在 AndroidManifest.xml 文件中 Activity 元素的 android:launchMode 属性。 应用场景 singleTop适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。 singleTask适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 singleInstance适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。","categories":[],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://wonderfulxin.github.io/tags/安卓/"}]},{"title":"观察者模式","slug":"观察者模式","date":"2016-12-23T03:35:00.000Z","updated":"2017-01-16T01:52:41.844Z","comments":true,"path":"2016/12/23/观察者模式/","link":"","permalink":"https://wonderfulxin.github.io/2016/12/23/观察者模式/","excerpt":"摘要:前几天面试的时候，说到这个问题观察者模式，面试官说setonclicklistener不是观察者模式，我当时也是楞了一下，硬是附和着面试官说不是观察者模式了~~其实点击事件是一个回调，但是同时也是一对一的观察者模式","text":"摘要:前几天面试的时候，说到这个问题观察者模式，面试官说setonclicklistener不是观察者模式，我当时也是楞了一下，硬是附和着面试官说不是观察者模式了~~其实点击事件是一个回调，但是同时也是一对一的观察者模式接下来我们看看观察者模式在android中的应用。我们从最简单的开始。还记得我们为一个Button设置点击事件的代码吗。Button btn=new Button(this);btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.e(“TAG”,”click”); }});其实严格意义上讲，这个最多算是回调，但是我们可以将其看成是一对一的观察者模式，即只有一个观察者。 其实只要是set系列的设置监听器的方法最多都只能算《回调》，但是有一些监听器式《add》进去的，这种就是观察者模式了，比如RecyclerView中的addOnScrollListener方法private List mScrollListeners;public void addOnScrollListener(OnScrollListener listener) { if (mScrollListeners == null) { mScrollListeners = new ArrayList(); } mScrollListeners.add(listener);}public void removeOnScrollListener(OnScrollListener listener) { if (mScrollListeners != null) { mScrollListeners.remove(listener); }}public void clearOnScrollListeners() { if (mScrollListeners != null) { mScrollListeners.clear(); }}然后有滚动事件时便会触发观察者进行方法回调public abstract static class OnScrollListener { public void onScrollStateChanged(RecyclerView recyclerView, int newState){} public void onScrolled(RecyclerView recyclerView, int dx, int dy){}} void dispatchOnScrolled(int hresult, int vresult) { //… if (mScrollListeners != null) { for (int i = mScrollListeners.size() - 1; i &gt;= 0; i–) { mScrollListeners.get(i).onScrolled(this, hresult, vresult); } }}void dispatchOnScrollStateChanged(int state) { //… if (mScrollListeners != null) { for (int i = mScrollListeners.size() - 1; i &gt;= 0; i–) { mScrollListeners.get(i).onScrollStateChanged(this, state); } }}类似的方法很多很多，都是add监听器系列的方法，这里也不再举例。 还有一个地方就是Android的广播机制，其本质也是观察者模式，这里为了简单方便，直接拿本地广播的代码说明，即LocalBroadcastManager。 我们平时使用本地广播主要就是下面四个方法LocalBroadcastManager localBroadcastManager=LocalBroadcastManager.getInstance(this);localBroadcastManager.registerReceiver(BroadcastReceiver receiver, IntentFilter filter);localBroadcastManager.unregisterReceiver(BroadcastReceiver receiver);localBroadcastManager.sendBroadcast(Intent intent)调用registerReceiver方法注册广播，调用unregisterReceiver方法取消注册，之后直接使用sendBroadcast发送广播，发送广播之后，注册的广播会收到对应的广播信息，这就是典型的观察者模式。具体的源代码这里也不贴。 android系统中的观察者模式还有很多很多，有兴趣的自己去挖掘，接下来我们看一下一些开源框架中的观察者模式。一说到开源框架，你首先想到的应该是EventBus。没错，EventBus也是基于观察者模式的。 观察者模式的三个典型方法它都具有，即注册，取消注册，发送事件EventBus.getDefault().register(Object subscriber);EventBus.getDefault().unregister(Object subscriber); EventBus.getDefault().post(Object event);内部源码也不展开了。","categories":[],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://wonderfulxin.github.io/tags/安卓/"}]},{"title":"markdown语法","slug":"hello-world","date":"2016-12-21T08:41:57.131Z","updated":"2016-12-26T09:27:37.849Z","comments":true,"path":"2016/12/21/hello-world/","link":"","permalink":"https://wonderfulxin.github.io/2016/12/21/hello-world/","excerpt":"","text":"摘要:markdown语法 正文:我的第一篇 斜体和粗体 斜体或斜体 粗体 加粗斜体 删除线 分级标题 一级标题 最大 二级标题 三级标题 四级标题 五级标题 六级标题","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://wonderfulxin.github.io/tags/其他/"}]}]}
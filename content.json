{"meta":{"title":"wonderful的自由空间","subtitle":"机遇总是留给有准备之人","description":"好的机遇总是留给有准备之人","author":"xiexin","url":"https://wonderfulxin.github.io"},"pages":[],"posts":[{"title":"使用 Git上传代码到coding.net代码仓库详解","slug":"使用git上传到coding","date":"2017-07-13T04:22:02.733Z","updated":"2017-07-13T04:37:54.841Z","comments":true,"path":"2017/07/13/使用git上传到coding/","link":"","permalink":"https://wonderfulxin.github.io/2017/07/13/使用git上传到coding/","excerpt":"摘要:使用 Git上传代码到coding.net代码仓库详解","text":"摘要:使用 Git上传代码到coding.net代码仓库详解 1.创建本地代码库 在本地创建一个文件夹，作为你上传代码的本地仓库，接下来就要把这个仓库与coding服务器端进行配置 在这个文件夹内点击右键，选择Git Bash Here，首先要初始化本地仓库，输入”git init”命令 接下来进行远程代码库克隆（前提：自行在coding中建立一个项目，空项目即可），输入”git clone https：//xxxxxx”命令，命令中的url获取方式如图： 左下角HHTPS处即为要输入的url 将这个url粘贴到命令中，进行远程仓库的克隆，克隆时会出现输入账号密码的环节（coding注册时的账号和密码） 输入账号密码之后便可以完成克隆。 2.代码推送 克隆之后在原来的文件夹中会多出一个文件夹（即从代码库中下载的文件夹），例如 这时候，本地仓库的配置就完成了，将要上传的代码文件放入这个文件夹中，接下来要查看一下本地仓库的状态，一检查配置是否成功，进而进行代码的推送，输入命令”git status” 例如放入了一个“stringKMP.c”文件之后输入命令”git status” 输入git status命令后，会发现以红色字体打印出来的“stringKMP.c”，说明该文件存在于本地仓库，但并未推送到云端， 接下来，输入”git add 文件名”命令，可以再输入命令”git status”进行状态检查，如下 会发现出现了“new file”。 接下来， 输入”git commit -m “代码备注随便写” “命令提交 然后输入”git push origin master”命令推送到云端，origin是服务器，master是分枝。 一切结束后，输入”git status”查看本地代码状态，会用绿字显示，表示上传成功，进入coding.Net的项目主页，你会发现自己在本地推送的代码已经出现在项目中。 以上就是使用Git上传代码到coding的流程，希望对大家有所帮助。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://wonderfulxin.github.io/tags/其他/"}]},{"title":"使用git发布文件的时候需要注意的东西","slug":"发布的git代码","date":"2017-07-13T03:35:00.000Z","updated":"2017-07-13T03:22:14.069Z","comments":true,"path":"2017/07/13/发布的git代码/","link":"","permalink":"https://wonderfulxin.github.io/2017/07/13/发布的git代码/","excerpt":"git上传自己的博客也好 上传文件也好首先你需要有一个git","text":"git上传自己的博客也好 上传文件也好首先你需要有一个git使用hexo+github搭建免费个人博客详细教程 http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html首先要下载node.js 然后下载hexo 对着c：目录下下载 $ npm install -g hexo-cli开启gitbush 找到对应的文件目录hexo g # 生成hexo s # 启动服务 一开始会弹出您的github登录 然后输入账号密码","categories":[],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://wonderfulxin.github.io/tags/安卓/"}]},{"title":"安卓嵌套listview gridview","slug":"安卓listview嵌套gridview","date":"2017-07-13T03:35:00.000Z","updated":"2017-07-13T03:12:20.501Z","comments":true,"path":"2017/07/13/安卓listview嵌套gridview/","link":"","permalink":"https://wonderfulxin.github.io/2017/07/13/安卓listview嵌套gridview/","excerpt":"摘要:经常在做安卓的时候会有这样的需求，listview嵌套gridview来使用","text":"摘要:经常在做安卓的时候会有这样的需求，listview嵌套gridview来使用 经常在做安卓的时候会有这样的需求，listview嵌套gridview来使用但是实际试过之后就会发现这样做有一个问题，无论ListView的高度怎么设置，都会只显示一行的高度，那是由于ListView的父容器测量模式为UNSPECIFIED的时候，gridviewView的高度默认为一个item的高度，这样我们就重写ListView的onMeasure方法，来自定义高度： public class FixedGridView extends GridView { public boolean onMeasure = false;//用于判断的布尔值，只有完成计算，即onLayout后才为false,在onMeasure时为true public FixedGridView(Context context) { super(context); } public FixedGridView(Context context, AttributeSet attrs) { super(context, attrs); } public FixedGridView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } //无论ListView的高度怎么设置，都会只显示一行的高度，那是由于ListView对于父容器测量模式为UNSPECIFIED时 // ListView的父容器测量模式为UNSPECIFIED的时候，ListView的高度默认为一个item的高度 //在measure里面重新计算一下高度 动态设置一下高度就可以了 @Override public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { onMeasure = true; int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2, MeasureSpec.AT_MOST); super.onMeasure(widthMeasureSpec, expandSpec + 4); } @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { onMeasure = false; super.onLayout(changed, l, t, r, b); } 好了 大功告成，这样子嵌套在listview就不会说只是显示一个item的高度啦","categories":[],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://wonderfulxin.github.io/tags/安卓/"}]},{"title":"安卓抽象布局--include、merge 、ViewStub","slug":"安卓抽象布局","date":"2017-03-02T03:35:00.000Z","updated":"2017-03-02T07:40:57.910Z","comments":true,"path":"2017/03/02/安卓抽象布局/","link":"","permalink":"https://wonderfulxin.github.io/2017/03/02/安卓抽象布局/","excerpt":"摘要:经常在做安卓的时候会用到这些东西，这些东西使得你加载的速度快了不止一倍","text":"摘要:经常在做安卓的时候会用到这些东西，这些东西使得你加载的速度快了不止一倍在布局优化中，Android官方提到了这三种布局 include、merge、ViewStub，并介绍了这三种布局各有的优势，下面也是简单说一下他们的优势，以及怎么使用，记下来权当做笔记。 1、布局重用include 使用如下： LinearLayout xmlns:android=”http://schemas.android.com/apk/res/android“ android:orientation=”vertical” android:layout_width=”match_parent” android:layout_height=”match_parent” android:background=”@color/app_bg” android:gravity=”center_horizontal”&gt; &lt;include layout=&quot;@layout/titlebar&quot;/&gt; &lt;TextView android:layout_width=”match_parent” android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/hello&quot; android:padding=&quot;10dp&quot; /&gt; LinearLayout 好处：我们写一个通用布局的时候可以用include重用，不至于写多遍，比如布局一个APP的顶部布局、侧边栏布局、底部Tab栏布局、ListView和GridView每一项的布局将这些同一个APP中有多个界面用到的布局抽取出来再通过include标签引用，既可以降低layout的复杂度，又可以做到布局重用 2、减少视图层级merge使用如下： merge xmlns:android=”http://schemas.android.com/apk/res/android&quot;&gt; &lt;Button android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/add&quot;/&gt; &lt;Button android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/delete&quot;/&gt; merge 好处：可以删减多余的层级，优化UI，从而减少视图在绘制过程消耗的时间，达到提高UI性能的效果。 3、需要时使用ViewStub 使用如下： ViewStub android:id=”@+id/stub_import” android:inflatedId=”@+id/panel_import” android:layout=”@layout/progress_overlay” android:layout_width=”fill_parent” android:layout_height=”wrap_content” android:layout_gravity=”bottom” /&gt;好处：最大的优点是当你需要时才会加载，他并不会影响UI初始化时的性能，各种不常用的布局想进度条、显示错误消息等可以使用标签，以减少内存使用量，加快渲染速度。是一个不可见的，大小为0的View。","categories":[],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://wonderfulxin.github.io/tags/安卓/"}]},{"title":"观察者模式","slug":"观察者模式","date":"2017-01-16T03:35:00.000Z","updated":"2017-01-16T03:34:23.113Z","comments":true,"path":"2017/01/16/观察者模式/","link":"","permalink":"https://wonderfulxin.github.io/2017/01/16/观察者模式/","excerpt":"摘要:前几天面试的时候，说到这个问题观察者模式，面试官说setonclicklistener不是观察者模式，我当时也是楞了一下，硬是附和着面试官说不是观察者模式了~~其实点击事件是一个回调，但是同时也是一对一的观察者模式","text":"摘要:前几天面试的时候，说到这个问题观察者模式，面试官说setonclicklistener不是观察者模式，我当时也是楞了一下，硬是附和着面试官说不是观察者模式了~~其实点击事件是一个回调，但是同时也是一对一的观察者模式接下来我们看看观察者模式在android中的应用。我们从最简单的开始。还记得我们为一个Button设置点击事件的代码吗。Button btn=new Button(this);btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Log.e(“TAG”,”click”); }});其实严格意义上讲，这个最多算是回调，但是我们可以将其看成是一对一的观察者模式，即只有一个观察者。 其实只要是set系列的设置监听器的方法最多都只能算《回调》，但是有一些监听器式《add》进去的，这种就是观察者模式了，比如RecyclerView中的addOnScrollListener方法private List mScrollListeners;public void addOnScrollListener(OnScrollListener listener) { if (mScrollListeners == null) { mScrollListeners = new ArrayList(); } mScrollListeners.add(listener);}public void removeOnScrollListener(OnScrollListener listener) { if (mScrollListeners != null) { mScrollListeners.remove(listener); }}public void clearOnScrollListeners() { if (mScrollListeners != null) { mScrollListeners.clear(); }}然后有滚动事件时便会触发观察者进行方法回调public abstract static class OnScrollListener { public void onScrollStateChanged(RecyclerView recyclerView, int newState){} public void onScrolled(RecyclerView recyclerView, int dx, int dy){}} void dispatchOnScrolled(int hresult, int vresult) { //… if (mScrollListeners != null) { for (int i = mScrollListeners.size() - 1; i &gt;= 0; i–) { mScrollListeners.get(i).onScrolled(this, hresult, vresult); } }}void dispatchOnScrollStateChanged(int state) { //… if (mScrollListeners != null) { for (int i = mScrollListeners.size() - 1; i &gt;= 0; i–) { mScrollListeners.get(i).onScrollStateChanged(this, state); } }}类似的方法很多很多，都是add监听器系列的方法，这里也不再举例。 还有一个地方就是Android的广播机制，其本质也是观察者模式，这里为了简单方便，直接拿本地广播的代码说明，即LocalBroadcastManager。 我们平时使用本地广播主要就是下面四个方法LocalBroadcastManager localBroadcastManager=LocalBroadcastManager.getInstance(this);localBroadcastManager.registerReceiver(BroadcastReceiver receiver, IntentFilter filter);localBroadcastManager.unregisterReceiver(BroadcastReceiver receiver);localBroadcastManager.sendBroadcast(Intent intent)调用registerReceiver方法注册广播，调用unregisterReceiver方法取消注册，之后直接使用sendBroadcast发送广播，发送广播之后，注册的广播会收到对应的广播信息，这就是典型的观察者模式。具体的源代码这里也不贴。 android系统中的观察者模式还有很多很多，有兴趣的自己去挖掘，接下来我们看一下一些开源框架中的观察者模式。一说到开源框架，你首先想到的应该是EventBus。没错，EventBus也是基于观察者模式的。 观察者模式的三个典型方法它都具有，即注册，取消注册，发送事件EventBus.getDefault().register(Object subscriber);EventBus.getDefault().unregister(Object subscriber); EventBus.getDefault().post(Object event);内部源码也不展开了。","categories":[],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://wonderfulxin.github.io/tags/安卓/"}]},{"title":"安卓activity四种启动模式","slug":"安卓四种启动模式","date":"2017-01-16T03:35:00.000Z","updated":"2017-01-16T03:34:04.665Z","comments":true,"path":"2017/01/16/安卓四种启动模式/","link":"","permalink":"https://wonderfulxin.github.io/2017/01/16/安卓四种启动模式/","excerpt":"摘要:安卓activity的四种启动模式在面试中也是经常会用到的","text":"摘要:安卓activity的四种启动模式在面试中也是经常会用到的1.standard 模式 标准模式，默认模式，每次激活都会重新创建activity，并且放到任务栈中2.singletop模式 要是在栈顶是你要启用的activity 那就会重用这个activity 要是不是这个就重新启动activity3.singletask模式 在栈里面查找要是有的话就复用 没有的话就重建4.signleInstance模式 外部应用也可以启动你这个activity 设置启动模式的位置在 AndroidManifest.xml 文件中 Activity 元素的 android:launchMode 属性。 应用场景 singleTop适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。 singleTask适合作为程序入口点。例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 singleInstance适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。","categories":[],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://wonderfulxin.github.io/tags/安卓/"}]},{"title":"安卓传递数据","slug":"Android基础 -- Activity之间传递数据（bitmap和map对象）","date":"2016-12-23T14:37:23.000Z","updated":"2017-05-31T02:49:28.514Z","comments":true,"path":"2016/12/23/Android基础 -- Activity之间传递数据（bitmap和map对象）/","link":"","permalink":"https://wonderfulxin.github.io/2016/12/23/Android基础 -- Activity之间传递数据（bitmap和map对象）/","excerpt":"摘要:安卓传递数据","text":"摘要:安卓传递数据正文:面试的时候遇到这个，记下来以后可以用，之前没有用过 第一个：传递bitmap 这个问题非常奇葩（可能我Android水平还不够），居然不会报错，我是直接用bundle或Intent的extral域直接存放bitmap，结果运行时各种宕机，各种界面乱窜（我非常的纳闷）。。。搜索之后看大家都说不能直接传递大于40k的图片，然后在德问论坛上找到了解法。就是把bitmap存储为byte数组，然后再通过Intent传递。 的 代码如下所示： Bitmap bmp=((BitmapDrawable)order_con_pic.getDrawable()).getBitmap();Intent intent=new Intent(OrderConfirm.this,ShowWebImageActivity.class);ByteArrayOutputStream baos=new ByteArrayOutputStream();bmp.compress(Bitmap.CompressFormat.PNG, 100, baos);byte [] bitmapByte =baos.toByteArray();intent.putExtra(“bitmap”, bitmapByte);startActivity(intent); 其中 第一行代码就是如何从一个imageview中获得其图片，这个问题也倒腾了下，貌似用setDrawingCacheEnabled也行，因为开始用的这个方法，但是直接在activity之间传递bitmap，所以导致运行时错误，后来改正之后没有再尝试。先new一个ByteArrayOutputStream流，然后使用Bitmap中的compress方法，把数据压缩到一个byte中，传输就可以了。 在另一个activity中取出来的方法是： imageView = (ZoomableImageView) findViewById(R.id.show_webimage_imageview); Intent intent=getIntent(); if(intent !=null) { byte [] bis=intent.getByteArrayExtra(“bitmap”); Bitmap bitmap=BitmapFactory.decodeByteArray(bis, 0, bis.length); imageView.setImageBitmap(bitmap); }取出来字节数组之后，用BitmapFactory中的decodeByteArray方法组合成一个bitmap就可以了。再加上一个存储的代码： public void saveMyBitmap(String bitName,Bitmap mBitmap) throws IOException { File f = new File(“/sdcard/Note/“ + bitName); if(!f.exists()) f.mkdirs();//如果没有这个文件夹的话，会报file not found错误 f=new File(“/sdcard/Note/“+bitName+”.png”); f.createNewFile(); try { FileOutputStream out = new FileOutputStream(f); mBitmap.compress(Bitmap.CompressFormat.PNG, 100, out); out.flush(); out.close(); } catch (FileNotFoundException e) { Log.i(TAG,e.toString()); } } 2.传递map对象： 封装到bundle中： Map data=orderlist.get(arg2-1); SerializableMap tmpmap=new SerializableMap(); tmpmap.setMap(data); bundle.putSerializable(“orderinfo”, tmpmap); intent.putExtras(bundle); 这个SeralizableMap是自己封装的一个实现了Serializable接口的类：public class SerializableMap implements Serializable { private Map map; public Map getMap() { return map; } public void setMap(Map map) { this.map=map; }}这样才能把map对象扔到bundle中去，取出来的方法是： Bundle bundle = getIntent().getExtras(); SerializableMap serializableMap = (SerializableMap) bundle .get(“orderinfo”);","categories":[{"name":"安卓","slug":"安卓","permalink":"https://wonderfulxin.github.io/categories/安卓/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://wonderfulxin.github.io/tags/其他/"}]},{"title":"面试经验","slug":"面试经验","date":"2016-12-23T14:37:23.000Z","updated":"2016-12-23T07:54:06.976Z","comments":true,"path":"2016/12/23/面试经验/","link":"","permalink":"https://wonderfulxin.github.io/2016/12/23/面试经验/","excerpt":"摘要:安卓面试经验","text":"摘要:安卓面试经验正文:我的第一篇","categories":[{"name":"日志","slug":"日志","permalink":"https://wonderfulxin.github.io/categories/日志/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://wonderfulxin.github.io/tags/其他/"}]},{"title":"html5 Video标签实现","slug":"video标签","date":"2016-12-23T03:35:00.000Z","updated":"2017-03-09T02:15:30.651Z","comments":true,"path":"2016/12/23/video标签/","link":"","permalink":"https://wonderfulxin.github.io/2016/12/23/video标签/","excerpt":"摘要:H5标签实现 在播放视频流的时候会自动全屏，可以实现不全屏","text":"摘要:H5标签实现 在播放视频流的时候会自动全屏，可以实现不全屏video标签还是比较常用的，在微信浏览器里面使用video标签，会自动变成全屏，改成下面就好了，起码可以在video标签之上加入其他元素。 id=\"videoID\"webkit-playsinline=\"true\" 123456x-webkit-airplay=&quot;true&quot; playsinline=&quot;true&quot;x5-video-player-type=&quot;h5&quot;x5-video-player-fullscreen=&quot;true&quot;width=&quot;100%&quot; height=&quot;100%&quot; preload=&quot;auto&quot; poster=&quot;&quot; src=&quot;&quot;&gt;&lt;/video&gt; 还有个问题，在Android的微信里面，就算加上了上面的属性，还会出现上下有黑边，不能全屏的问题。解决办法：给video加上object-fit: fill;的style属性。实现方法：id=\"videoplayer\" controls=\"controls\"'+ 1234&apos;tabindex=&quot;0&quot; preload=&quot;metadata&quot; style=&quot;width:100%; height: 100%; overflow: hidden;object-fit: fill;&quot; &apos;+&apos;poster=&quot;http://sun1.wxdg.sun0769.com/ImageResource/video.jpg&quot; &apos;+&apos;webkit-playsinline=&quot;true&quot; x-webkit-airplay=&quot;true&quot; playsinline=&quot;true&quot; &apos;+&apos;x5-video-player-fullscreen=&quot;true&quot;&gt;&lt;/video&gt;&apos;","categories":[],"tags":[{"name":"H5","slug":"H5","permalink":"https://wonderfulxin.github.io/tags/H5/"}]},{"title":"html传参数乱码","slug":"传参数乱码","date":"2016-12-23T03:35:00.000Z","updated":"2017-01-09T03:41:53.654Z","comments":true,"path":"2016/12/23/传参数乱码/","link":"","permalink":"https://wonderfulxin.github.io/2016/12/23/传参数乱码/","excerpt":"摘要:有时候会遇到传H5参数会乱码，就是一个页面用get方法带去参数，之后在另外一个页面获取参数会乱码，顺便写出获取参数的方法","text":"摘要:有时候会遇到传H5参数会乱码，就是一个页面用get方法带去参数，之后在另外一个页面获取参数会乱码，顺便写出获取参数的方法//获取参数的方法function getQueryString(name) { var reg = new RegExp(“(^|&amp;)” + name + “=([^&amp;]*)(&amp;|$)”, “i”); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;}在一个URL带上参数例如：http://127.0.0.1:8020/index.html?id=205&amp;department=部门但是这个中文会乱码，在获取的时候，这个时候我们要先给部门两个中文字先encode 之后再获取的时候再解码：index.html?id=’+id+’&amp;department=’+escape(department)+’然后获取的时候就直接unescape(getQueryString(‘department’)) 获取出来的就不是乱码了。","categories":[],"tags":[{"name":"H5","slug":"H5","permalink":"https://wonderfulxin.github.io/tags/H5/"}]},{"title":"压缩图片单例Util","slug":"ZipUtil","date":"2016-12-23T03:35:00.000Z","updated":"2016-12-23T07:54:13.873Z","comments":true,"path":"2016/12/23/ZipUtil/","link":"","permalink":"https://wonderfulxin.github.io/2016/12/23/ZipUtil/","excerpt":"摘要:压缩图片的工具类，内存经常由于图片占用空间大而内存溢出，有了这个压缩最起码会好好多。","text":"摘要:压缩图片的工具类，内存经常由于图片占用空间大而内存溢出，有了这个压缩最起码会好好多。public class ZipUtil {private static ZipUtil instance;private ZipUtil() {}public static synchronized ZipUtil getInstance() {if (instance == null) { instance = new ZipUtil();} return instance;}private File compressImage(Bitmap image) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); image.compress(Bitmap.CompressFormat.JPEG, 100, baos);//质量压缩方法，这里100表示 不压缩，把压缩后的数据存放到baos中 int options = 100; while ( baos.toByteArray().length / 1024&gt;200) { //循环判断如果压缩后图片是否大于200kb,大于继续压缩 baos.reset();//重置baos即清空baos image.compress(Bitmap.CompressFormat.JPEG, options, baos);//这里压缩options%，把压缩后的数据存放到baos中 options -= 10;//每次都减少10 }// ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());//把压缩后的数据baos存放到ByteArrayInputStream中// Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null);//把ByteArrayInputStream数据生成图片 new DateFormat(); String name = DateFormat.format(“yyyyMMdd_hhmmss”,Calendar.getInstance(Locale.CHINA)) + “.JPEG”; File f = new File( “/sdcard/Image/“+name); try { FileOutputStream fos = new FileOutputStream(f); fos.write(baos.toByteArray()); fos.flush(); fos.close(); } catch (Exception e) { e.printStackTrace(); } return f; }public File getimage(String srcPath) { BitmapFactory.Options newOpts = new BitmapFactory.Options(); //开始读入图片，此时把options.inJustDecodeBounds 设回true了 newOpts.inJustDecodeBounds = true; Bitmap bitmap = BitmapFactory.decodeFile(srcPath,newOpts);//此时返回bm为空 newOpts.inJustDecodeBounds = false; int w = newOpts.outWidth; int h = newOpts.outHeight; //现在主流手机比较多是800*480分辨率，所以高和宽我们设置为 float hh = 800f;//这里设置高度为800f float ww = 480f;//这里设置宽度为480f //缩放比。由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可 int be = 1;//be=1表示不缩放 if (w &gt; h &amp;&amp; w &gt; ww) {//如果宽度大的话根据宽度固定大小缩放 be = (int) (newOpts.outWidth / ww); } else if (w &lt; h &amp;&amp; h &gt; hh) {//如果高度高的话根据宽度固定大小缩放 be = (int) (newOpts.outHeight / hh); } if (be &lt;= 0) be = 1; newOpts.inSampleSize = be;//设置缩放比例 //重新读入图片，注意此时已经把options.inJustDecodeBounds 设回false了 bitmap = BitmapFactory.decodeFile(srcPath, newOpts); return compressImage(bitmap);//压缩好比例大小后再进行质量压缩 }}","categories":[],"tags":[{"name":"安卓","slug":"安卓","permalink":"https://wonderfulxin.github.io/tags/安卓/"}]},{"title":"markdown语法","slug":"markdown语法","date":"2016-12-21T08:41:57.132Z","updated":"2017-03-02T07:06:29.161Z","comments":true,"path":"2016/12/21/markdown语法/","link":"","permalink":"https://wonderfulxin.github.io/2016/12/21/markdown语法/","excerpt":"","text":"摘要:markdown语法 正文:我的第一篇 斜体和粗体 斜体或斜体 粗体 加粗斜体 删除线 分级标题 一级标题 最大 二级标题 三级标题 四级标题 五级标题 六级标题 &lt; 与 &amp; 1.&lt;会不显示，要写&amp;lt 2.&amp;要写&amp;amp 如果你确实想要依赖 Markdown 来插入 标签的话，在插入处先按入两个以上的空格然后回车。","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"https://wonderfulxin.github.io/tags/其他/"}]}]}
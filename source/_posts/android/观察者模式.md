---
date:  2017-1-16 11:35
status: public
title: 观察者模式
tags:
  - 安卓
---

摘要:前几天面试的时候，说到这个问题观察者模式，面试官说setonclicklistener不是观察者模式，我当时也是楞了一下，硬是附和着面试官说不是观察者模式了~~其实点击事件是一个回调，但是同时也是一对一的观察者模式
<!--more-->
接下来我们看看观察者模式在android中的应用。我们从最简单的开始。还记得我们为一个Button设置点击事件的代码吗。
Button btn=new Button(this);
btn.setOnClickListener(new View.OnClickListener() {
	@Override
	public void onClick(View v) {
		Log.e("TAG","click");
	}
});
其实严格意义上讲，这个最多算是回调，但是我们可以将其看成是一对一的观察者模式，即只有一个观察者。

其实只要是set系列的设置监听器的方法最多都只能算《回调》，但是有一些监听器式《add》进去的，这种就是观察者模式了，比如RecyclerView中的addOnScrollListener方法
private List<OnScrollListener> mScrollListeners;
public void addOnScrollListener(OnScrollListener listener) {
	if (mScrollListeners == null) {
		mScrollListeners = new ArrayList<OnScrollListener>();
	}
	mScrollListeners.add(listener);
}
public void removeOnScrollListener(OnScrollListener listener) {
	if (mScrollListeners != null) {
		mScrollListeners.remove(listener);
	}
}
public void clearOnScrollListeners() {
	if (mScrollListeners != null) {
		mScrollListeners.clear();
	}
}
然后有滚动事件时便会触发观察者进行方法回调
public abstract static class OnScrollListener {
	public void onScrollStateChanged(RecyclerView recyclerView, int newState){}
	public void onScrolled(RecyclerView recyclerView, int dx, int dy){}
}

void dispatchOnScrolled(int hresult, int vresult) {
	//...
	if (mScrollListeners != null) {
		for (int i = mScrollListeners.size() - 1; i >= 0; i--) {
			mScrollListeners.get(i).onScrolled(this, hresult, vresult);
		}
	}
}
void dispatchOnScrollStateChanged(int state) {
	//...
	if (mScrollListeners != null) {
		for (int i = mScrollListeners.size() - 1; i >= 0; i--) {
			mScrollListeners.get(i).onScrollStateChanged(this, state);
		}
	}
}
类似的方法很多很多，都是add监听器系列的方法，这里也不再举例。

还有一个地方就是Android的广播机制，其本质也是观察者模式，这里为了简单方便，直接拿本地广播的代码说明，即LocalBroadcastManager。

我们平时使用本地广播主要就是下面四个方法
LocalBroadcastManager localBroadcastManager=LocalBroadcastManager.getInstance(this);
localBroadcastManager.registerReceiver(BroadcastReceiver receiver, IntentFilter filter);
localBroadcastManager.unregisterReceiver(BroadcastReceiver receiver);
localBroadcastManager.sendBroadcast(Intent intent)
调用registerReceiver方法注册广播，调用unregisterReceiver方法取消注册，之后直接使用sendBroadcast发送广播，发送广播之后，注册的广播会收到对应的广播信息，这就是典型的观察者模式。具体的源代码这里也不贴。

android系统中的观察者模式还有很多很多，有兴趣的自己去挖掘，接下来我们看一下一些开源框架中的观察者模式。一说到开源框架，你首先想到的应该是EventBus。没错，EventBus也是基于观察者模式的。

观察者模式的三个典型方法它都具有，即注册，取消注册，发送事件
EventBus.getDefault().register(Object subscriber);
EventBus.getDefault().unregister(Object subscriber);

EventBus.getDefault().post(Object event);
内部源码也不展开了。
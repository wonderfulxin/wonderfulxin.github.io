
---
date: 2020-04-1
status: public
title: JVM
tags:
  - JAVA
---

摘要:java
<!--more-->
# 一图看懂JVM
![avatar](/img/jvm.jpg)

# 类加载器 运行时数据区 执行引擎

# JVM  如何判断一个对象要回收了
## 引用计数：jvm对象有一个计数器，每次有人引用它的时候计数器加一，如果取消引用的话计数器减一，JVM判断如果引用计数为0的时候就回收
## 可达性分析：jvm会从GC Roots开始向下搜索，搜索所走过的路劲叫引用链，当一个对象到GC ROOTS没有任何引用链的时候，证明对象不可用了，为不可达对象，这个时候会被垃圾回收器回收

#引用的分类  
## 强引用
jvm 不会回收这个对象，就算到OOM 也不回收
## 软引用
jvm 只要内存不够的时候就会回收这个引用，一般不回收这个对象
## 弱引用
jvm 发现之后就会回收这个对象，但是垃圾回收期是一个优先级很低的线程，所以不一定很快就会发现这些弱引用的对象
## 虚引用
jvm 看到就会回收，虚引用顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。
如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

#垃圾回收(GC)及垃圾回收器  GC 收集器
垃圾回收机老年代包括：CMS  G1 
年轻代回收器：ParNew

# JVM 调优
jps jmc 阿里arthas

# JVM 调优指令
## 指令
1.jps命令用于查询正在运行的JVM进程。
2.jstat可以实时显示本地或者远程JVM进程中类的装载、内存、垃圾收集、JIT编译等数据。
3.jinfo用于查询当前运行的JVM的属性和参数值。
4.jmap用于显示当前Java堆和永久代的详细信息。
5.jhat用于分析使用jmap生成的dump文件，是JDK自带的工具。
6.jstack用于生成当前JVM所有线程的快照，线程快照是JVM每一个线程正在执行的方法，目的是定位出线程出现长时间停顿的原因。
## 参数
1.-Xmx：用于指定Java程序的最大堆内存，使用java -Xmx5000M -version判断当前系统能分配的最大堆内存。
2.-Xms：指定最小堆内存，通常设置成跟最大堆内存一样，减少GC。
3.-Xmn：设置新生代大小。整个堆内存 = 新生代内存 + 老年代内存，此值对系统性能影响较大，Sun官方推荐设置为堆的3/8。
4.-Xss：指定线程的最大栈空间。该参数决定了java函数调用的深度，值越大调用深度越深，若值太小，容易发生栈溢出错误。
5.-XX:PermSize ：指定方法区（永久区）的初始值，默认是物理内存的1/64，Java8永久区移除之后，取而代之的是元数据区，由-XX:MetaspaceSize指定。
6.-XX:MaxPermSize ：指定方法区（永久区）的最大值，默认是物理内存的1/4，Java8永久区移除之后，取而代之的是元数据区，由-XX:MaxMetaspaceSize指定。
7.-XX:NewRatio=n：老年代和新生代比值，n=2时，说明老年代和新生代的比值为2:1。
8.-XX:SurvivorRatio=n：Eden区和Survivor区的比值。n=8时，说明Eden和Survivor比值为8：1：1，因为Survivor有两个（from，to）

# JVM 里面有什么
## 堆
放对象，new关键字和构造器创建的对象
### 堆--新生代 比例1  主要用的是复制算法  伊甸园区主要用标记清除，suviver区主要用复制算法
新生代有伊甸园区和 suviver区-比例8:1:1  ------主要对应的是minor GC  就是把已经没有GC root引用的数据给清除掉
### 堆--老年代 比例2  主要用的是标记-整理算法
对应的是老年代  主要是FULL GC ----- 对应着会 STW stop the word 导致全世界停顿  如果进行full GC 之后，内存还是不够的时候，就会抛出异常OOM
### JVM 调优主要是为了少点FULL GC 和加快FULL GC 的速度

### 为什么15次之后就到老年代
因为对象头里面有四个bit 代表的是GC的年龄 0000，每次young GC  就加一 主要是复制算法，这里到达1111 则是15次如果再加就没有位数了
所以就是因为这样 15次GC之后就放到老年代

### 还有一个问题，什么时候对象进入老年代？
1、对象的分代年龄到了15岁
2、大对象直接进入老年代，就是大对象在新生代放不下，进行minor GC之后还是不够的情况下，会直接放入老年代。

## 栈
放一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存
### 局部变量表
### 操作数栈
### 方法出口
## 方法区 jdk 1.6 之后 叫元空间
主要存放常量 静态方法等
## 程序计数器
保存当前栈到达哪行运算位置了
## 本地方法栈
调用一些native方法，C++的方法都是通过本地方法栈调用的  unsafe类里面的cas

# 栈内存溢出会报StackOverflowError  堆溢出会报OOM


# JVM 和 HotSpot什么区别
JVM 一个规范 一个标准 

HotSpot 是一个产品  一个实现  sun 公司开发的 亲儿子  所以一般用的 就是这个
J9 是一个产品  一个实现
taobaovm 是一个产品  一个实现

openJDK--- 一个C++项目  编译出来就是 HotSpot   openJDK就是开源的HotSpot代码  HotSpot有20%是商业用的代码  openJDK没有


# 遇到过OOM吗  怎么造成的，怎么处理的
内存不够的时候  static等关键字用的多了 由于老年代不够用了 怎么old GC 都没用了 这个时候就会OOM

1，使用软引用
2，尽量少用static
3，加内存条


# 对象是放在哪里的
对象实例是放在堆里面，对象引用是放在栈里面，对象静态方法是放在元空间

# 主要内存回收算法
## 复制 主要用于suviver区
## 标记清理 主要用于young 区
## 标记整理 主要用于old区

# 大对象多大就会直接到老年代
大于伊甸园区的50%  就直接到老年代

# CMS
CMS 垃圾回收算法，是标记清理算法 用于old 区
CMS并非没有暂停，而是用两次短暂停来替代串行标记整理算法的长暂停，它的收集周期是这样：
初始标记(CMS-initial-mark) -> 并发标记(CMS-concurrent-mark) -> 重新标记(CMS-remark) -> 并发清除(CMS-concurrent-sweep) 
->并发重设状态等待下次CMS的触发(CMS-concurrent-reset)。其中的1，3两个步骤需要暂停所有的应用程序线程的。
第一次暂停从root对象开始标记存活的对象，这个阶段称为初始标记；第二次暂停是在并发标记之后， 暂停所有应用程序线程，
重新标记并发标记阶段遗漏的对象（在并发标记阶段结束后对象状态的更新导致）。
第一次暂停会比较短，第二次暂停通常会比较长，并且 remark这个阶段可以并行标记。

# G1 
G1 标记整理算法 

# 垃圾回收器从线程运行情况分类有三种
串行回收，Serial回收器，单线程回收，全程stw；
并行回收，名称以Parallel开头的回收器，多线程回收，全程stw；
并发回收，cms与G1，多线程分阶段回收，只有某阶段会stw；

# CMS 处理过程有七个步骤： 
1. 初始标记(CMS-initial-mark) ,会导致swt；
2. 并发标记(CMS-concurrent-mark)，与用户线程同时运行； 
3. 预清理（CMS-concurrent-preclean），与用户线程同时运行； 
4. 可被终止的预清理（CMS-concurrent-abortable-preclean） 与用户线程同时运行； 
5. 重新标记(CMS-remark) ，会导致swt； 
6. 并发清除(CMS-concurrent-sweep)，与用户线程同时运行； 
7. 并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行； 
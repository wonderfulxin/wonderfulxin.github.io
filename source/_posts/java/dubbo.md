
---
date: 2020-04-1
status: public
title: dubbo
tags:
  - JAVA
---

摘要:java
<!--more-->
# dubbo 序列化
默认序列化 hassian2序列化
还有其他序列化，json序列化，java序列化java.io.Serializable，FastJson

##浅谈Java序列化和hessian序列化的差异
首先，hessian序列化比Java序列化高效很多，而且生成的字节流也要短很多。但相对来说没有Java序列化可靠，而且也不如Java序列化支持的全面；
先说Java序列化，具体工作原理就不说了，Java序列化会把要序列化的对象类的元数据和业务数据全部序列化从字节流，而且是把整个继承关系上的东西全部序列化了。
它序列化出来的字节流是对那个对象结构到内容的完全描述，包含所有的信息，因此效率较低而且字节流比较大。但是由于确实是序列化了所有内容，
所以可以说什么都可以传输，因此也更可用和可靠。

而hessian序列化，它的实现机制是着重于数据，附带简单的类型信息的方法。就像Integer a = 1，hessian会序列化成I 1这样的流，
I表示int or Integer，1就是数据内容。而对于复杂对象，通过Java的反射机制，hessian把对象所有的属性当成一个Map来序列化，
产生类似M className propertyName1 I 1 propertyName S stringValue（大概如此，确切的忘了）这样的流，包含了基本的类型描述和数据内容。
而在序列化过程中，如果一个对象之前出现过，hessian会直接插入一个R index这样的块来表示一个引用位置，从而省去再次序列化和反序列化的时间。
这样做的代价就是hessian需要对不同的类型进行不同的处理（因此hessian直接偷懒不支持short），而且遇到某些特殊对象还要做特殊的处理（比如StackTraceElement）。
而且同时因为并没有深入到实现内部去进行序列化，所以在某些场合会发生一定的不一致，比如通过Collections.synchronizedMap得到的map。

## 为什么需要序列化
序列化是将一个对象变成一个二进制流就是序列化， 反序列化是将二进制流转换成对象。
1. 减小内存空间和网络传输的带宽
2. 分布式的可扩展性
3. 通用性，接口可共用

## dubbo 跟 springcloud 有什么区别
一个走rpc 远程过程调用服务，另外一个走http协议，底层rpc 服务直接调用另外一个服务的方法，就想调用本地方法一样，有个长连接
这样就减少了http三次握手四次挥手的网络带宽，

RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http 一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；
发布、下线接口、动态扩展等，对调用方来说是无感知、统 一化的操作。第三个来说就是安全性。最后就是最近流行的服务化架构、服务化治理，RPC框架是一个强力的支撑



# rpc服务
## 为什么需要rpc服务
rpc服务是远程进程间通信，就是允许程序调用另一个地址空间的过程或者函数，因为现在很多公司内部有很多大大小小的许多服务，部署在不同机器，
如果服务间都走网络通信，那未免太复杂，太过繁琐而且容易出错，如果能像本地调用一个远程连接一样就好了，这就是rpc远程调用

## 如何通信
1，事先已经写好通信地址，类似于服务注册
2，通过tcp直接调用传输到对应地址
3，然后通过序列化和反反序列化传输数据

## 一个基本的RPC架构里面应该至少包含以下4个组件：
1、客户端（Client）:服务调用方（服务消费者）
2、客户端存根（Client Stub）:存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端
3、服务端存根（Server Stub）:接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理
4、服务端（Server）:服务的真正提供者

## RPC的三个过程
1通信协议
2寻址
3序列化(将对象转换成网络可以传输的二进制)

## zk服务注册发现过程，如果一个断了，怎么通知到对方
这里写的非常清楚[zk服务注册发现过程](https://blog.csdn.net/zyhlwzy/article/details/101847565)
1，要清楚zk的数据模型，主要是一个树形结构，也就是目录结构 eg:/11/22/33 数据模型中的每一个节点，Zookeeper称之为Znode
2，zk的watcher机制，和znode绑定的一个监听器，当有节点不提供服务的时候自动提示
3，具体流程
1）客户端调用getData方法向服务器获取某个Znode节点的数据时，设置watch为true。
服务端接到请求后，返回节点的数据，并在维护的WatchTable中插入被Watch的Znode路径以及Watcher（watch该Znode的客户端）；
2）当被Watch的Znode被删除或者更新之后，Zookeeper服务器会查找Watch Table，找到在Znode上对应的所有Watcher，
异步通知对应的客户端，并且删除Watch Table中对应的Key：Value；
4，zk的服务注册和发现流程
1）服务注册：服务提供者（Provider）启动时，会向Zookeeper服务端注册服务信息，
即会在Zookeeper服务器上创建一个服务节点，并在节点上存储服务的相关数据（如服务提供者的ip地址、端口等），
比如注册一个用户注册服务（user/register）:
2）服务发现：服务消费者（Consumer）启动时，会根据本身依赖的服务信息，向Zookeeper服务端获取注册的服务信息并设置Watch，
获取到注册的服务信息之后将服务提供者信息缓存在本地，调用服务时直接根据从Zookeeper注册中心获取到的服务注册信息调用服务，
比如发现用户注册服务（user/register）并调用。
3）服务通知（类似服务心跳检测）：当服务提供者因为某种原因宕机或不提供服务之后，Zookeeper服务注册中心的对应服务节点会被删除，
因为服务消费者在获取服务信息的时候在对应节点上设置了Watch，因此节点删除之后会触发对应的Watcher，
Zookeeper注册中心会异步向服务所关联的所有服务消费者发出节点删除的通知，服务消费者根据收到的通知更新缓存的服务列表。

## zk节点类型
1.持久节点(PERSISTENT)
持久节点，创建后一直存在，直到主动删除此节点。
2.持久顺序节点(PERSISTENT_SEQUENTIAL)
持久顺序节点，创建后一直存在，直到主动删除此节点。在ZK中，每个父节点会为它的第一级子节点维护一份时序，记录每个子节点创建的先后顺序。
3.临时节点(EPHEMERAL)
临时节点在客户端会话失效后节点自动清除。临时节点下面不能创建子节点。
4.顺序临时节点(EPHEMERAL_SEQUENTIAL)
临时节点在客户端会话失效后节点自动清除。临时节点下面不能创建子节点。父节点getChildren会获得顺序的节点列表。

## zk还可以用来做什么，具体怎么实现
1,分布式锁，具体实现方式
1）znode 可以被监控。
节点数据修改、子节点变化、节点删除等。
一旦变化可以通知设置监控的客户端。
通过这个特性可以实现的功能包括配置的集中管理，集群管理，分布式锁等等。
2）分布式锁步骤。
注：zk设置watcher的操作和读操作是原子的。读取子节点列表同时设置监听器
	1. 父节点持久节点/lock
	2. 所有客户端在/lock下创建 瞬时有序节点/lock/seq-0000000000、/lock/seq-0000000001、依次类推
	3. 获取/lock下所有子节点getChildren("/lock")方法，判断自己是否为最小的。是：获取锁； 否：监听自己前一位子节点的删除消息(调用exist()方法，同时注册事件监听。 )，
	获得通知后重复该步骤。
	4. 执行代码。完成后释放锁。
3）使用zookeeper + curator，完成分布式锁。



## zk集群架构
zk集群由多个节点组成，其中有且仅有一个leader，处理所有事务请求；follower及observer统称learner。learner需要同步leader的数据。follower还参与选举及事务决策过程。
zk客户端会打散配置文件中的serverAddress 顺序并随机组成新的list，然后循环按序取一个服务器地址进行连接，直到成功。follower及observer会将事务请求转交给leader处理。
ZXID：每次对Zookeeper的状态的改变都会产生一个zxid（ZooKeeper Transaction Id），zxid是全局有序的，如果zxid1小于zxid2，则zxid1在zxid2之前发生。
## 事务ID 概念
ZooKeeper状态的每次变化都接收一个ZXID（ZooKeeper事务id）形式的标记。ZXID是一个64位的数字，由Leader统一分配，全局唯一，不断递增。
ZXID展示了所有的ZooKeeper的变更顺序。每次变更会有一个唯一的zxid，如果zxid1小于zxid2说明zxid1在zxid2之前发生。
## ZK 选举过程
### zk启动节点的时候的选举过程
(1) 每个Server发出一个投票。由于是初始情况，ZK1和ZK2都会将自己作为Leader服务器来进行投票，每次投票会包含所推举的服务器的myid和ZXID，使用(myid, ZXID)来表示，此时ZK1的投票为(1, 0)，ZK2的投票为(2, 0)，然后各自将这个投票发给集群中其他机器。
(2) 接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器。
(3) 处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行比较，规则如下
　　　　· 优先检查ZXID。ZXID比较大的服务器优先作为Leader。
　　　　· 如果ZXID相同，那么就比较myid。myid较大的服务器作为Leader服务器。
对于ZK1而言，它的投票是(1, 0)，接收ZK2的投票为(2, 0)，首先会比较两者的ZXID，均为0，再比较myid，此时ZK2的myid最大，于是ZK2胜。ZK1更新自己的投票为(2, 0)，并将投票重新发送给ZK2。
(4) 统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于ZK1、ZK2而言，都统计出集群中已经有两台机器接受了(2, 0)的投票信息，此时便认为已经选出ZK2作为Leader。
(5) 改变服务器状态。一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING。当新的Zookeeper节点ZK3启动时，发现已经有Leader了，不再选举，直接将直接的状态从LOOKING改为FOLLOWING。
### zk 一台机器挂了之后怎么选举
(1) 变更状态。Leader挂后，余下的非Observer服务器都会讲自己的服务器状态变更为LOOKING，然后开始进入Leader选举过程。
(2) 每个Server会发出一个投票。在运行期间，每个服务器上的ZXID可能不同，此时假定ZK1的ZXID为124，ZK3的ZXID为123；在第一轮投票中，ZK1和ZK3都会投自己，产生投票(1, 124)，(3, 123)，然后各自将投票发送给集群中所有机器。
(3) 接收来自各个服务器的投票。与启动时过程相同。
(4) 处理投票。与启动时过程相同，由于ZK1事务ID大，ZK1将会成为Leader。
(5) 统计投票。与启动时过程相同。
(6) 改变服务器的状态。与启动时过程相同。


## Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。
实现这个机制的协议叫做Zab协议（ZooKeeper Atomic Broadcast protocol）。
Zab协议有两种模式，它们分别是恢复模式（Recovery选主）和广播模式（Broadcast同步）。


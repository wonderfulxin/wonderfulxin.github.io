---
date: 2020-03-17
status: public
title: redis机制
tags:
  - JAVA 
  - redis
---

摘要:redis机制
<!--more-->


## 底层原理
redis 是基于C 语言写的 ，基于内存的底层的，key-value  ，nosql 数据库

## redis 特点
### 硬盘持久化
持久化方式： RDB AOF  
RDB 就是快照缓存，就是每次都是生成一个RDB 文件，然后覆盖掉之前的文件，redis默认是RDB，save 和 bgsave 会触发这个缓存，然后生成一个RDB文件，一段时间之后替换
AOF 就是每次进行操作的时候，都会把操作命令写到AOF 文件里面，会把每个命令都写到AOF 文件里面，这就导致AOF文件比较大

RDB AOF 选择，默认是RDB，RDB恢复大数据集的时候会更快，RDB缺点就是一段时间才开启一次快照缓存，如果这段时间宕机了，这段时间的数据就丢失了
AOF 只是对RDB的一个补充，AOF 默认是不开启的，AOF是实时写进命令的，所以一般宕机啥的数据恢复都不会丢失，但是这个命令一直写进去AOF文件，就导致数据文件非常大

Slaver先将Master那边获取到的信息压入磁盘，再load进内存，client端是从内存中读取信息的，所以Redis是内存数据库。

### 主从模式
主从复制，防止数据丢失 ,读写分离，在主节点写入，其他节点读出

### 哨兵模式
选主的概念，当主宕机之后就会立马，从几个从节点当中选主

## 支持的数据类型
String set list sortset map

## sortset 是什么数据格式
跳跃表，所谓跳跃表就是一个链表，原本这个链表查询是需要从1->10这样子查询，但是跳表实现了多层查询，通过分层1->5,6->10这样子查询
当查询数字为5的时候，跳表只要查一次就行，大大加快了效率
利用sortset实现延迟队列，在卡夫卡里面是不能实现延迟队列的，这些都是消息队列，来一个消费一个，达到解耦削锋异步的效果，
但是要实现延迟多少时间固定消费哪些消息，这个卡夫卡是做不到，但是redis的sortset是可以实现的，先用过把所有消息都用时间来作为score，
score 就是set的key，当一段时间之后就通过ZRANGEBYSCORE查询出所有的消息，包括已过期和当前达到时间的消息体，
再消费之后通过ZREM 来消除这个消息体，但是这个不是原子的，可能使得一条消息被消费多次，需要lua脚本保证原子性
时间复杂度O(Log(N))

## redis 与Memcached对比
1，redis支持数据类型多，mencached只支持string
2，redis支持主从，高可用
3，redis支持哨兵模式
4，redis 速度快，单线程
5，redis 支持持久化

## nosql
非关系型数据库，

## 缓存雪崩
这个问题是大量请求的时候，请求一个接口，这个时候会设置一个缓存来缓存数据，这样子别人来请求的时候就会读取缓存，缓解数据库压力，但是在缓存时间过期的时候，
这个时候还是会有大量请求回过来，这个时候redis压力过大，就会出现缓存雪崩，要尽量把缓存失效时间分散一点，同时对于不常用的key要过滤掉，永久不失效
##缓存穿透
外界请求不断请求一个没有缓存的key  一直请求，而且是一次性大量操作来请求你的接口，这个就叫缓存穿透。解决办法是尽量把不需要用的key过滤掉，然后永久不失效
另外一个解决办法是布隆过滤器

## 缓存雪崩怎么解决
1，加上一个map存在key里面，每次都检查一遍看下有没有对应的key，就不用去查数据库了
2，缓存雪崩主要是大量的key失效，导致请求一起来，这个要设置各个key的过期时间尽量均匀，不要同一时间过期

## 布隆过滤器(Bloom Filter)详解
直观的说，bloom算法类似一个hash set，用来判断某个元素（key）是否在某个集合中。
和一般的hash set不同的是，这个算法无需存储key的值，对于每个key，只需要k个比特位，每个存储一个标志，用来判断key是否在集合中。

算法：
1. 首先需要k个hash函数，每个函数可以把key散列成为1个整数
2. 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0
3. 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1
4. 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。

## redis的分布式锁
这个时候还是需要让redis 设置锁来实现，setnx， set if not exits，
如果在设置锁之后，更新缓存意外退出了，这个时候还要给锁设置一个过期时间，但是setnx 没有设置过期时间，这个时候还需要expire 来设置过期时间

## 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
使用keys指令可以扫出指定模式的key列表。如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？
这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。
这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，
但是整体所花费的时间会比直接用keys指令长。

## redis 集群
### 主从复制原理
从节点发送 SYNC 命令的主服务器将开始执行 BGSAVE ， 并在保存操作执行期间， 将所有新执行的写入命令都保存到一个缓冲区里面。
当 BGSAVE 执行完毕后， 主服务器将执行保存操作所得的 .rdb 文件发送给从服务器， 从服务器接收这个 .rdb 文件， 
并将文件中的数据载入到内存中
### redis cluster
Redis 集群采用  Gossip（流言）协议，Gossip 协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，
这种方式类似流言传播。通过不断发送ping/pong，每个节点都会单独开一个TCP通道，彼此通信
三主三从，这里采用去中心化，

### redis 槽 重新分配的时候，它是怎么提供服务的
他会一个槽一个槽的转移，当这个时候客户端来查询的时候，源节点会先在自己的数据库里面查找指定的键，如果找到的话，
就直接执行客户端发送的命令，相反地，如果源节点没能在自己的数据库里面找到指定的键，
那么这个键有可能已经被迁移到了目标节点，
源节点将向客户端返回一个ASK错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令

## redis缓存 怎么解决map 存储大量数据
存储到bitmap 里面 ，bitmap 可以存储大量数据


#redis 过期键删除策略
## 设置key的过期删除指令
通过EXPIRE命令或者PEXPIRE命令
EXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl秒

EXPIRE、PEXPIRE和EXPIREAT三个命令都会转换成PEXPIREAT命令来执行

##  过期字典
redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典

##  key剩余时间查询 TTL
剩余时间要是无限的话就返回-1，TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间
##  主节点的过期删除策略
1，定时删除，创建键值的同时创建一个定时器，在时间到期之后删除键值 -----对cpu不友好
2，惰性删除，就是放任键值过期，每次来取值的时候就检查一遍时间是否过期了 -----对内存不友好
3，定期删除，一段时间就删除一大片的过期数据

Redis服务器实际使用的是惰性删除和定期删除两种策略

定期删除的原理，可以设置一段时间检查一定数量数据库中的一定数量的key过期，有个全局变量会纪录当前检查到哪个库了，例如这次检查1-10，下次检查就从11开始检查了
然后等全部库检查完之后又是把这个值设置为0开始，检查单个库的时候会有一定时间检查key 有无过期，一定时间过去之后就轮到下一个库了

##  从节点的过期策略
从节点过期key是如何删除的呢？主节点在key到期时，会在AOF文件里增加一条del指令。
AOF文件被同步到从节点以后，从节点根据AOF中的这个del指令来执行删除过期key的操作。

# 内存溢出控制策略
1，noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。
2，allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。
3，allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。
4，volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。
5，volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。
6，volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。如果没有对应的键，则回退到noeviction策略。

# redis slot 为什么是16384个
因为作者觉得够用了，在增加节点的时候，搭建者要给两个几点发送meet指令，发送完成之后两个节点就会不断发送ping，和pong的通信了
，但是ping的指令里面是包括数据的（消息体和消息头组成），如果这个槽的大小为65535的话2……16的话 那就数据量很大了，会很慢，同事redis设计初衷
，节点不会超过1一千个，所以作者觉得16384够用了。

# redis 哨兵的选举算法
会对slave进行排序
（1）按照slave优先级进行排序，slave priority越低，优先级就越高
（2）如果slave priority相同，那么看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高
（3）如果上面两个条件都相同，那么选择一个run id比较小的那个slave


# redis 事务
redis 的事务其实就是一堆命令的集合，其顺序如下：
multi : 标记一个事务块的开始
set，命令入队列
exec : 执行所有事务块的命令，一旦执行会锁住
discard : 取消事务，放弃事务块中的所有命令

# redis 工具类
springframework RedisTemplate->RedisConnectionFactory->Jedis pool
jedis Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件
Jedis的基本使用非常简单，只需要创建Jedis对象的时候指定host，port, password即可
Jedis是Redis官方推荐的面向Java的操作Redis的客户端，而RedisTemplate是SpringDataRedis中对JedisApi的高度封装。
SpringDataRedis相对于Jedis来说可以方便地更换Redis的Java客户端，
比Jedis多了自动管理连接池的特性，方便与其他Spring框架进行搭配使用

# redis主从是怎么同步的
全量同步
Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： 
-  从服务器连接主服务器，发送SYNC命令； 
-  主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； 
-  主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； 
-  从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 
-  主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； 
-  从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；
-  
增量同步
Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 
增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。‘

# 红锁
分布式多个地方都加锁，只有超过一半的锁成功了 才说明成功加锁了
# 读写锁
读多写少，读读不互斥  读写互斥  写写互斥

# redis工具使用
删除CacheRefresh开头的数据
```bash
redis-cli --scan --pattern "CacheRefresh:*" | xargs redis-cli del
```
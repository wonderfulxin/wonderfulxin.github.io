---
date: 2020-11-26
status: public
title: 线程池
tags:
  - JAVA
---

摘要:线程池
<!--more-->
# 线程
在说线程池之前要先说线程，什么是线程？资源调用最小单位
## 线程实现方式
JDK 1.5前 
1，继承Thread 实现run方法
2，实现runnable接口 实现run方法
JDK 1.5后
实现Callable 接口 实现Call 方法
call方法可以返回结果到Future,Future 有get 方法可以获取到call 方法的返回
调用方式是new Thread.start(Callable); 底层是传callable 过去然后获取到执行结果然后set一下
## start 和run 有啥区别
start 是会新起一个线程来执行，可以实现多线程；run方法只是方法级别的调用，直接用调用主线程来执行方法

## 一个线程两次调用start()方法会出现什么情况？谈谈线程的生命周期和状态转移。
Java的线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。
新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。
就绪（RUNNABLE），表示该线程已经在JVM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它CPU片段，在就绪队列里面排队。
在其他一些分析中，会额外区分一种状态RUNNING，但是从Java API的角度，并不能表示出来。
阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待Monitor lock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。
等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费线程可以继续工作了。Thread.join()也会令线程进入等待状态。
计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本，如下面示例：
public final native void wait(long timeout) throws InterruptedException;
终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。

# 线程池
## 线程池分类
线程池分类主要分为四种：
1，newCachedThreadPool 线程无限大，如果线程都在运行的话，就不断新建线程来运行任务，如果有线程没在运行的话，就复用  工作队列  SynchronousQueue  核心线程没用
缺点 ： worke 为N  这个时候 CPU 会消耗很大
2，newFixedThreadPool 线程数为固定，如果大于这个线程数的话就队列中等待  工作队列  LinkedBlockingQueue  非核心线程没用
缺点 ： 队列无限 内存占用太多  容易 OOM
3，newSingleThreadPool 单个核心线程数，一直复用这个线程运行任务  工作队列  LinkedBlockingQueue  newCache的单一线程版本
缺点 ： 队列无限 内存占用太多  容易 OOM
4，newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行

## 线程池继承（线程池 多个请求来的时候  你去其他地方请求接口你怎么知道回来数据了）
线程池最下面的是ThreadPoolExcutor，其实他是集成AbstrictExcutorService 又集成了ExcutorService接口，然后又集成了Excutor接口。
Excutor 主要有一个Excutor方法，执行runnable接口，但是run方法没有返回值是一个void类型；ExcutorService接口增加了submit方法，
里面可以执行callable方法Future、Call方法，Future的get方法在获取结果时候将进入阻塞，阻塞直到Callable中的call返回。

## ThreadPoolExcutor （线程池 参数）
参数：七个参数，包括 1核心线程数corepoolsize 2 maximunsize最大线程数 3 worker队列 4 保活时间 5 保活时间单位 
6 threadfactory 线程工厂 7 拒绝策略
实现原理： 进来一个线程，先获取当前工作线程数 1 如果小于核心线程数，则创建线程来执行 2 如果大于核心线程数 小于最大线程数，
而且工作队列还不满，则创建线程进入工作队列 3 如果大于核心线程数，小于最大线程数，工作队列已满，则创建额外线程来执行 
4 如果超过最大线程，则走拒绝策略

提交顺序 核心线程-》工作队列-》非核心线程
执行顺序 核心线程-》非核心线程-》工作队列

## 线程池拒绝策略
1，abortpolicy 直接抛出异常 2，discardPolicy 直接抛弃任务而且不抛出异常 
3，discardOldestPolisy 把最远的任务抛弃，然后把拒绝的任务加上 4，callerRunsPolicy直接用调用的线程来执行这个线程

## 线程池用于什么地方
数据库主要是为了解决 1 资源复用 2 提高效率 3 提高性能
主要使用场景 1，去数据库查询的时候多个线程池去查提高效率 2，调用第三方接口的时候，同时执行提高效率 3

## 线程池五个状态
1、RUNNING
(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。
(02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！

private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
2、 SHUTDOWN

(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。
(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -> SHUTDOWN。

3、STOP

(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。
(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。

4、TIDYING

(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。
(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。
当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。

5、 TERMINATED

(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。
(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。

# 线程池怎么知道各个线程都执行完毕了
 Future是一个接口，他提供给了我们方法来检测当前的任务是否已经结束，
 还可以等待任务结束并且拿到一个结果，通过调用Future的get（）方法可以当任务结束后返回一个结果值，
 如果线程里的任何一个线程工作没有结束，则线程会自动阻塞，直到任务执行完毕，
 我们可以通过调用cancel（）方法来停止一个任务，如果任务已经停止，则cancel（）方法会返回true；
 如果任务已经完成或者已经停止了或者这个任务无法停止，则cancel（）会返回一个false。
 当一个任务被成功停止后，他无法再次执行。isDone（）和isCancel（）方法可以判断当前工作是否完成和是否取消，
 他的作用通过callable的回调获得我们请求的结果。
 线程都是通过实现callable接口，然后实现submit 方法 提交信息
 
 # 线程池有哪些工作队列
 1、ArrayBlockingQueue
 是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。
 2、LinkedBlockingQueue
 一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列
 3、SynchronousQueue
 一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool（5）使用了这个队列。
 4、PriorityBlockingQueue
 一个具有优先级的无限阻塞队列。